/*   1:    */ package jcifs.util;
/*   2:    */ 
/*   3:    */ import java.io.PrintStream;
/*   4:    */ 
/*   5:    */ public class DES
/*   6:    */ {
/*   7: 76 */   private int[] encryptKeys = new int[32];
/*   8: 77 */   private int[] decryptKeys = new int[32];
/*   9: 79 */   private int[] tempInts = new int[2];
/*  10:    */   
/*  11:    */   public DES() {}
/*  12:    */   
/*  13:    */   public DES(byte[] key)
/*  14:    */   {
/*  15: 88 */     if (key.length == 7)
/*  16:    */     {
/*  17: 89 */       byte[] key8 = new byte[8];
/*  18: 90 */       makeSMBKey(key, key8);
/*  19: 91 */       setKey(key8);
/*  20:    */     }
/*  21:    */     else
/*  22:    */     {
/*  23: 93 */       setKey(key);
/*  24:    */     }
/*  25:    */   }
/*  26:    */   
/*  27:    */   public static void makeSMBKey(byte[] key7, byte[] key8)
/*  28:    */   {
/*  29:102 */     key8[0] = ((byte)(key7[0] >> 1 & 0xFF));
/*  30:103 */     key8[1] = ((byte)(((key7[0] & 0x1) << 6 | (key7[1] & 0xFF) >> 2 & 0xFF) & 0xFF));
/*  31:104 */     key8[2] = ((byte)(((key7[1] & 0x3) << 5 | (key7[2] & 0xFF) >> 3 & 0xFF) & 0xFF));
/*  32:105 */     key8[3] = ((byte)(((key7[2] & 0x7) << 4 | (key7[3] & 0xFF) >> 4 & 0xFF) & 0xFF));
/*  33:106 */     key8[4] = ((byte)(((key7[3] & 0xF) << 3 | (key7[4] & 0xFF) >> 5 & 0xFF) & 0xFF));
/*  34:107 */     key8[5] = ((byte)(((key7[4] & 0x1F) << 2 | (key7[5] & 0xFF) >> 6 & 0xFF) & 0xFF));
/*  35:108 */     key8[6] = ((byte)(((key7[5] & 0x3F) << 1 | (key7[6] & 0xFF) >> 7 & 0xFF) & 0xFF));
/*  36:109 */     key8[7] = ((byte)(key7[6] & 0x7F));
/*  37:110 */     for (int i = 0; i < 8; i++) {
/*  38:111 */       key8[i] = ((byte)(key8[i] << 1));
/*  39:    */     }
/*  40:    */   }
/*  41:    */   
/*  42:    */   public void setKey(byte[] key)
/*  43:    */   {
/*  44:119 */     deskey(key, true, this.encryptKeys);
/*  45:120 */     deskey(key, false, this.decryptKeys);
/*  46:    */   }
/*  47:    */   
/*  48:    */   private void deskey(byte[] keyBlock, boolean encrypting, int[] KnL)
/*  49:    */   {
/*  50:127 */     int[] pc1m = new int[56];
/*  51:128 */     int[] pcr = new int[56];
/*  52:129 */     int[] kn = new int[32];
/*  53:131 */     for (int j = 0; j < 56; j++)
/*  54:    */     {
/*  55:132 */       int l = pc1[j];
/*  56:133 */       int m = l & 0x7;
/*  57:134 */       pc1m[j] = ((keyBlock[(l >>> 3)] & bytebit[m]) != 0 ? 1 : 0);
/*  58:    */     }
/*  59:137 */     for (int i = 0; i < 16; i++)
/*  60:    */     {
/*  61:    */       int m;
/*  62:    */       int m;
/*  63:139 */       if (encrypting) {
/*  64:140 */         m = i << 1;
/*  65:    */       } else {
/*  66:142 */         m = 15 - i << 1;
/*  67:    */       }
/*  68:143 */       int n = m + 1; int 
/*  69:144 */         tmp122_121 = 0;kn[n] = tmp122_121;kn[m] = tmp122_121;
/*  70:145 */       for (j = 0; j < 28; j++)
/*  71:    */       {
/*  72:146 */         int l = j + totrot[i];
/*  73:147 */         if (l < 28) {
/*  74:148 */           pcr[j] = pc1m[l];
/*  75:    */         } else {
/*  76:150 */           pcr[j] = pc1m[(l - 28)];
/*  77:    */         }
/*  78:    */       }
/*  79:152 */       for (j = 28; j < 56; j++)
/*  80:    */       {
/*  81:153 */         int l = j + totrot[i];
/*  82:154 */         if (l < 56) {
/*  83:155 */           pcr[j] = pc1m[l];
/*  84:    */         } else {
/*  85:157 */           pcr[j] = pc1m[(l - 28)];
/*  86:    */         }
/*  87:    */       }
/*  88:159 */       for (j = 0; j < 24; j++)
/*  89:    */       {
/*  90:160 */         if (pcr[pc2[j]] != 0) {
/*  91:161 */           kn[m] |= bigbyte[j];
/*  92:    */         }
/*  93:162 */         if (pcr[pc2[(j + 24)]] != 0) {
/*  94:163 */           kn[n] |= bigbyte[j];
/*  95:    */         }
/*  96:    */       }
/*  97:    */     }
/*  98:166 */     cookey(kn, KnL);
/*  99:    */   }
/* 100:    */   
/* 101:    */   private void cookey(int[] raw, int[] KnL)
/* 102:    */   {
/* 103:174 */     int i = 0;int rawi = 0;
/* 104:174 */     for (int KnLi = 0; i < 16; i++)
/* 105:    */     {
/* 106:175 */       int raw0 = raw[(rawi++)];
/* 107:176 */       int raw1 = raw[(rawi++)];
/* 108:177 */       KnL[KnLi] = ((raw0 & 0xFC0000) << 6);
/* 109:178 */       KnL[KnLi] |= (raw0 & 0xFC0) << 10;
/* 110:179 */       KnL[KnLi] |= (raw1 & 0xFC0000) >>> 10;
/* 111:180 */       KnL[KnLi] |= (raw1 & 0xFC0) >>> 6;
/* 112:181 */       KnLi++;
/* 113:182 */       KnL[KnLi] = ((raw0 & 0x3F000) << 12);
/* 114:183 */       KnL[KnLi] |= (raw0 & 0x3F) << 16;
/* 115:184 */       KnL[KnLi] |= (raw1 & 0x3F000) >>> 4;
/* 116:185 */       KnL[KnLi] |= raw1 & 0x3F;
/* 117:186 */       KnLi++;
/* 118:    */     }
/* 119:    */   }
/* 120:    */   
/* 121:    */   private void encrypt(byte[] clearText, int clearOff, byte[] cipherText, int cipherOff)
/* 122:    */   {
/* 123:194 */     squashBytesToInts(clearText, clearOff, this.tempInts, 0, 2);
/* 124:195 */     des(this.tempInts, this.tempInts, this.encryptKeys);
/* 125:196 */     spreadIntsToBytes(this.tempInts, 0, cipherText, cipherOff, 2);
/* 126:    */   }
/* 127:    */   
/* 128:    */   private void decrypt(byte[] cipherText, int cipherOff, byte[] clearText, int clearOff)
/* 129:    */   {
/* 130:202 */     squashBytesToInts(cipherText, cipherOff, this.tempInts, 0, 2);
/* 131:203 */     des(this.tempInts, this.tempInts, this.decryptKeys);
/* 132:204 */     spreadIntsToBytes(this.tempInts, 0, clearText, clearOff, 2);
/* 133:    */   }
/* 134:    */   
/* 135:    */   private void des(int[] inInts, int[] outInts, int[] keys)
/* 136:    */   {
/* 137:212 */     int keysi = 0;
/* 138:    */     
/* 139:214 */     int leftt = inInts[0];
/* 140:215 */     int right = inInts[1];
/* 141:    */     
/* 142:217 */     int work = (leftt >>> 4 ^ right) & 0xF0F0F0F;
/* 143:218 */     right ^= work;
/* 144:219 */     leftt ^= work << 4;
/* 145:    */     
/* 146:221 */     work = (leftt >>> 16 ^ right) & 0xFFFF;
/* 147:222 */     right ^= work;
/* 148:223 */     leftt ^= work << 16;
/* 149:    */     
/* 150:225 */     work = (right >>> 2 ^ leftt) & 0x33333333;
/* 151:226 */     leftt ^= work;
/* 152:227 */     right ^= work << 2;
/* 153:    */     
/* 154:229 */     work = (right >>> 8 ^ leftt) & 0xFF00FF;
/* 155:230 */     leftt ^= work;
/* 156:231 */     right ^= work << 8;
/* 157:232 */     right = right << 1 | right >>> 31 & 0x1;
/* 158:    */     
/* 159:234 */     work = (leftt ^ right) & 0xAAAAAAAA;
/* 160:235 */     leftt ^= work;
/* 161:236 */     right ^= work;
/* 162:237 */     leftt = leftt << 1 | leftt >>> 31 & 0x1;
/* 163:239 */     for (int round = 0; round < 8; round++)
/* 164:    */     {
/* 165:240 */       work = right << 28 | right >>> 4;
/* 166:241 */       work ^= keys[(keysi++)];
/* 167:242 */       int fval = SP7[(work & 0x3F)];
/* 168:243 */       fval |= SP5[(work >>> 8 & 0x3F)];
/* 169:244 */       fval |= SP3[(work >>> 16 & 0x3F)];
/* 170:245 */       fval |= SP1[(work >>> 24 & 0x3F)];
/* 171:246 */       work = right ^ keys[(keysi++)];
/* 172:247 */       fval |= SP8[(work & 0x3F)];
/* 173:248 */       fval |= SP6[(work >>> 8 & 0x3F)];
/* 174:249 */       fval |= SP4[(work >>> 16 & 0x3F)];
/* 175:250 */       fval |= SP2[(work >>> 24 & 0x3F)];
/* 176:251 */       leftt ^= fval;
/* 177:252 */       work = leftt << 28 | leftt >>> 4;
/* 178:253 */       work ^= keys[(keysi++)];
/* 179:254 */       fval = SP7[(work & 0x3F)];
/* 180:255 */       fval |= SP5[(work >>> 8 & 0x3F)];
/* 181:256 */       fval |= SP3[(work >>> 16 & 0x3F)];
/* 182:257 */       fval |= SP1[(work >>> 24 & 0x3F)];
/* 183:258 */       work = leftt ^ keys[(keysi++)];
/* 184:259 */       fval |= SP8[(work & 0x3F)];
/* 185:260 */       fval |= SP6[(work >>> 8 & 0x3F)];
/* 186:261 */       fval |= SP4[(work >>> 16 & 0x3F)];
/* 187:262 */       fval |= SP2[(work >>> 24 & 0x3F)];
/* 188:263 */       right ^= fval;
/* 189:    */     }
/* 190:266 */     right = right << 31 | right >>> 1;
/* 191:267 */     work = (leftt ^ right) & 0xAAAAAAAA;
/* 192:268 */     leftt ^= work;
/* 193:269 */     right ^= work;
/* 194:270 */     leftt = leftt << 31 | leftt >>> 1;
/* 195:271 */     work = (leftt >>> 8 ^ right) & 0xFF00FF;
/* 196:272 */     right ^= work;
/* 197:273 */     leftt ^= work << 8;
/* 198:274 */     work = (leftt >>> 2 ^ right) & 0x33333333;
/* 199:275 */     right ^= work;
/* 200:276 */     leftt ^= work << 2;
/* 201:277 */     work = (right >>> 16 ^ leftt) & 0xFFFF;
/* 202:278 */     leftt ^= work;
/* 203:279 */     right ^= work << 16;
/* 204:280 */     work = (right >>> 4 ^ leftt) & 0xF0F0F0F;
/* 205:281 */     leftt ^= work;
/* 206:282 */     right ^= work << 4;
/* 207:283 */     outInts[0] = right;
/* 208:284 */     outInts[1] = leftt;
/* 209:    */   }
/* 210:    */   
/* 211:    */   public void encrypt(byte[] clearText, byte[] cipherText)
/* 212:    */   {
/* 213:290 */     encrypt(clearText, 0, cipherText, 0);
/* 214:    */   }
/* 215:    */   
/* 216:    */   public void decrypt(byte[] cipherText, byte[] clearText)
/* 217:    */   {
/* 218:296 */     decrypt(cipherText, 0, clearText, 0);
/* 219:    */   }
/* 220:    */   
/* 221:    */   public byte[] encrypt(byte[] clearText)
/* 222:    */   {
/* 223:304 */     int length = clearText.length;
/* 224:306 */     if (length % 8 != 0)
/* 225:    */     {
/* 226:307 */       System.out.println("Array must be a multiple of 8");
/* 227:308 */       return null;
/* 228:    */     }
/* 229:311 */     byte[] cipherText = new byte[length];
/* 230:312 */     int count = length / 8;
/* 231:314 */     for (int i = 0; i < count; i++) {
/* 232:315 */       encrypt(clearText, i * 8, cipherText, i * 8);
/* 233:    */     }
/* 234:317 */     return cipherText;
/* 235:    */   }
/* 236:    */   
/* 237:    */   public byte[] decrypt(byte[] cipherText)
/* 238:    */   {
/* 239:325 */     int length = cipherText.length;
/* 240:327 */     if (length % 8 != 0)
/* 241:    */     {
/* 242:328 */       System.out.println("Array must be a multiple of 8");
/* 243:329 */       return null;
/* 244:    */     }
/* 245:332 */     byte[] clearText = new byte[length];
/* 246:333 */     int count = length / 8;
/* 247:335 */     for (int i = 0; i < count; i++) {
/* 248:336 */       encrypt(cipherText, i * 8, clearText, i * 8);
/* 249:    */     }
/* 250:338 */     return clearText;
/* 251:    */   }
/* 252:    */   
/* 253:344 */   private static byte[] bytebit = { -128, 64, 32, 16, 8, 4, 2, 1 };
/* 254:348 */   private static int[] bigbyte = { 8388608, 4194304, 2097152, 1048576, 524288, 262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1 };
/* 255:356 */   private static byte[] pc1 = { 56, 48, 40, 32, 24, 16, 8, 0, 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 60, 52, 44, 36, 28, 20, 12, 4, 27, 19, 11, 3 };
/* 256:366 */   private static int[] totrot = { 1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28 };
/* 257:370 */   private static byte[] pc2 = { 13, 16, 10, 23, 0, 4, 2, 27, 14, 5, 20, 9, 22, 18, 11, 3, 25, 7, 15, 6, 26, 19, 12, 1, 40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47, 43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31 };
/* 258:381 */   private static int[] SP1 = { 16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756 };
/* 259:399 */   private static int[] SP2 = { -2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344 };
/* 260:417 */   private static int[] SP3 = { 520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584 };
/* 261:435 */   private static int[] SP4 = { 8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928 };
/* 262:453 */   private static int[] SP5 = { 256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080 };
/* 263:471 */   private static int[] SP6 = { 536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312 };
/* 264:489 */   private static int[] SP7 = { 2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154 };
/* 265:507 */   private static int[] SP8 = { 268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696 };
/* 266:    */   
/* 267:    */   public static void squashBytesToInts(byte[] inBytes, int inOff, int[] outInts, int outOff, int intLen)
/* 268:    */   {
/* 269:531 */     for (int i = 0; i < intLen; i++) {
/* 270:532 */       outInts[(outOff + i)] = ((inBytes[(inOff + i * 4)] & 0xFF) << 24 | (inBytes[(inOff + i * 4 + 1)] & 0xFF) << 16 | (inBytes[(inOff + i * 4 + 2)] & 0xFF) << 8 | inBytes[(inOff + i * 4 + 3)] & 0xFF);
/* 271:    */     }
/* 272:    */   }
/* 273:    */   
/* 274:    */   public static void spreadIntsToBytes(int[] inInts, int inOff, byte[] outBytes, int outOff, int intLen)
/* 275:    */   {
/* 276:543 */     for (int i = 0; i < intLen; i++)
/* 277:    */     {
/* 278:545 */       outBytes[(outOff + i * 4)] = ((byte)(inInts[(inOff + i)] >>> 24));
/* 279:546 */       outBytes[(outOff + i * 4 + 1)] = ((byte)(inInts[(inOff + i)] >>> 16));
/* 280:547 */       outBytes[(outOff + i * 4 + 2)] = ((byte)(inInts[(inOff + i)] >>> 8));
/* 281:548 */       outBytes[(outOff + i * 4 + 3)] = ((byte)inInts[(inOff + i)]);
/* 282:    */     }
/* 283:    */   }
/* 284:    */ }


/* Location:           G:\ParasiteTrade\Parasite_20150226.jar
 * Qualified Name:     jcifs.util.DES
 * JD-Core Version:    0.7.0.1
 */